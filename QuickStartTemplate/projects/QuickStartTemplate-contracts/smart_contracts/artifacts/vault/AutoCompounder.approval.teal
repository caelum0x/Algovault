#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 3000 10000
    bytecblock 0x151f7c75 "compoundsActive" "totalUsersEnabled" "compoundFeeRate" "admin" "totalCompounds" "_enabled" "totalRewardsCompounded" "averageEfficiency" "bestEfficiency" "_frequency" "_threshold" "_maxGasFee" "_lastCompound" 0x151f7c750000000000000000 "feeCollector" "lastGlobalCompound" "_slippageTolerance"
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txn NumAppArgs
    bz main_bare_routing@25
    pushbytess 0x6d79c89c 0x0fe93bce 0x726bcbe1 0xd7021f77 0x231f673f 0x893a0ebe 0xbae90038 0x9f163dc1 0xa7ecb6d8 0xa7056935 0x4e825a90 0x0e136baa 0xc94bf3db 0xbf77a915 0xda29bb89 0x004e6bec 0x2342c0eb 0xd6f2f27c 0xfe57ab5c 0x2d3bc29c // method "initialize(byte[],byte[],uint64,byte[])void", method "enableAutoCompound(uint64,uint64,uint64,uint64)void", method "disableAutoCompound()void", method "triggerCompound(byte[],uint64)uint64", method "executeCompound(byte[],uint64,uint64)uint64", method "batchCompound(byte[][],uint64[])uint64", method "calculateCompoundEfficiency(uint64,uint64)uint64", method "recordCompoundHistory(byte[],uint64,uint64,uint64,uint64)void", method "updateGlobalStats(uint64,uint64)void", method "updateCompoundFee(uint64)void", method "updateFeeCollector(byte[])void", method "pauseCompounds()void", method "resumeCompounds()void", method "isEligibleForCompound(byte[])bool", method "getUserSettings(byte[])(uint64,uint64,uint64,uint64,uint64)", method "getCompoundStats()(uint64,uint64,uint64,uint64,uint64,uint64)", method "getPendingRewards(byte[])uint64", method "estimateGasCost()uint64", method "calculateOptimalCompoundTime(byte[])uint64", method "projectCompoundValue(byte[],uint64)uint64"
    txna ApplicationArgs 0
    match main_initialize_route@3 main_enableAutoCompound_route@4 main_disableAutoCompound_route@5 main_triggerCompound_route@6 main_executeCompound_route@7 main_batchCompound_route@8 main_calculateCompoundEfficiency_route@9 main_recordCompoundHistory_route@10 main_updateGlobalStats_route@11 main_updateCompoundFee_route@12 main_updateFeeCollector_route@13 main_pauseCompounds_route@14 main_resumeCompounds_route@15 main_isEligibleForCompound_route@16 main_getUserSettings_route@17 main_getCompoundStats_route@18 main_getPendingRewards_route@19 main_estimateGasCost_route@20 main_calculateOptimalCompoundTime_route@21 main_projectCompoundValue_route@22

main_after_if_else@29:
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    intc_0 // 0
    return

main_projectCompoundValue_route@22:
    // smart_contracts/vault/auto_compounder.algo.ts:379
    // projectCompoundValue(user: bytes, timeHorizon: uint64): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 14 // 0x151f7c750000000000000000
    log
    intc_1 // 1
    return

main_calculateOptimalCompoundTime_route@21:
    // smart_contracts/vault/auto_compounder.algo.ts:369
    // calculateOptimalCompoundTime(user: bytes): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/vault/auto_compounder.algo.ts:369
    // calculateOptimalCompoundTime(user: bytes): uint64 {
    callsub calculateOptimalCompoundTime
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_estimateGasCost_route@20:
    // smart_contracts/vault/auto_compounder.algo.ts:361
    // estimateGasCost(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c750000000000000bb8
    log
    intc_1 // 1
    return

main_getPendingRewards_route@19:
    // smart_contracts/vault/auto_compounder.algo.ts:351
    // getPendingRewards(user: bytes): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 14 // 0x151f7c750000000000000000
    log
    intc_1 // 1
    return

main_getCompoundStats_route@18:
    // smart_contracts/vault/auto_compounder.algo.ts:338
    // getCompoundStats(): [uint64, uint64, uint64, uint64, uint64, uint64] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getCompoundStats
    uncover 5
    itob
    uncover 5
    itob
    uncover 5
    itob
    uncover 5
    itob
    uncover 5
    itob
    uncover 5
    itob
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getUserSettings_route@17:
    // smart_contracts/vault/auto_compounder.algo.ts:323
    // getUserSettings(user: bytes): [uint64, uint64, uint64, uint64, uint64] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/vault/auto_compounder.algo.ts:323
    // getUserSettings(user: bytes): [uint64, uint64, uint64, uint64, uint64] {
    callsub getUserSettings
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_isEligibleForCompound_route@16:
    // smart_contracts/vault/auto_compounder.algo.ts:296
    // isEligibleForCompound(user: bytes): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/vault/auto_compounder.algo.ts:296
    // isEligibleForCompound(user: bytes): boolean {
    callsub isEligibleForCompound
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_resumeCompounds_route@15:
    // smart_contracts/vault/auto_compounder.algo.ts:288
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub resumeCompounds
    intc_1 // 1
    return

main_pauseCompounds_route@14:
    // smart_contracts/vault/auto_compounder.algo.ts:281
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pauseCompounds
    intc_1 // 1
    return

main_updateFeeCollector_route@13:
    // smart_contracts/vault/auto_compounder.algo.ts:274
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/vault/auto_compounder.algo.ts:274
    // @abimethod()
    callsub updateFeeCollector
    intc_1 // 1
    return

main_updateCompoundFee_route@12:
    // smart_contracts/vault/auto_compounder.algo.ts:266
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/vault/auto_compounder.algo.ts:266
    // @abimethod()
    callsub updateCompoundFee
    intc_1 // 1
    return

main_updateGlobalStats_route@11:
    // smart_contracts/vault/auto_compounder.algo.ts:252
    // updateGlobalStats(compoundedAmount: uint64, efficiency: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/vault/auto_compounder.algo.ts:252
    // updateGlobalStats(compoundedAmount: uint64, efficiency: uint64): void {
    callsub updateGlobalStats
    intc_1 // 1
    return

main_recordCompoundHistory_route@10:
    // smart_contracts/vault/auto_compounder.algo.ts:236-242
    // recordCompoundHistory(
    //   user: bytes,
    //   rewardAmount: uint64,
    //   compoundedAmount: uint64,
    //   gasCost: uint64,
    //   efficiency: uint64
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/vault/auto_compounder.algo.ts:236-242
    // recordCompoundHistory(
    //   user: bytes,
    //   rewardAmount: uint64,
    //   compoundedAmount: uint64,
    //   gasCost: uint64,
    //   efficiency: uint64
    // ): void {
    callsub recordCompoundHistory
    intc_1 // 1
    return

main_calculateCompoundEfficiency_route@9:
    // smart_contracts/vault/auto_compounder.algo.ts:228
    // calculateCompoundEfficiency(rewardAmount: uint64, gasCost: uint64): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/vault/auto_compounder.algo.ts:228
    // calculateCompoundEfficiency(rewardAmount: uint64, gasCost: uint64): uint64 {
    callsub calculateCompoundEfficiency
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_batchCompound_route@8:
    // smart_contracts/vault/auto_compounder.algo.ts:157
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/vault/auto_compounder.algo.ts:157
    // @abimethod()
    callsub batchCompound
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_executeCompound_route@7:
    // smart_contracts/vault/auto_compounder.algo.ts:130
    // executeCompound(user: bytes, rewardAmount: uint64, gasCost: uint64): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/vault/auto_compounder.algo.ts:130
    // executeCompound(user: bytes, rewardAmount: uint64, gasCost: uint64): uint64 {
    callsub executeCompound
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_triggerCompound_route@6:
    // smart_contracts/vault/auto_compounder.algo.ts:99
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/vault/auto_compounder.algo.ts:99
    // @abimethod()
    callsub triggerCompound
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_disableAutoCompound_route@5:
    // smart_contracts/vault/auto_compounder.algo.ts:87
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub disableAutoCompound
    intc_1 // 1
    return

main_enableAutoCompound_route@4:
    // smart_contracts/vault/auto_compounder.algo.ts:59
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/vault/auto_compounder.algo.ts:59
    // @abimethod()
    callsub enableAutoCompound
    intc_1 // 1
    return

main_initialize_route@3:
    // smart_contracts/vault/auto_compounder.algo.ts:35
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    extract 2 0
    // smart_contracts/vault/auto_compounder.algo.ts:35
    // @abimethod()
    callsub initialize
    intc_1 // 1
    return

main_bare_routing@25:
    // smart_contracts/vault/auto_compounder.algo.ts:12
    // export class AutoCompounder extends Contract {
    txn OnCompletion
    bnz main_after_if_else@29
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.initialize(stakingPool: bytes, rewardDistributorAddr: bytes, compoundFee: uint64, feeCollector: bytes) -> void:
initialize:
    // smart_contracts/vault/auto_compounder.algo.ts:35-41
    // @abimethod()
    // initialize(
    //   stakingPool: bytes,
    //   rewardDistributorAddr: bytes,
    //   compoundFee: uint64,
    //   feeCollector: bytes
    // ): void {
    proto 4 0
    // smart_contracts/vault/auto_compounder.algo.ts:29
    // compoundsActive = GlobalState<boolean>()
    intc_0 // 0
    bytec_1 // "compoundsActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:42
    // assert(!this.compoundsActive.value)
    !
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:24
    // stakingPoolContract = GlobalState<bytes>()
    pushbytes "stakingPoolContract"
    // smart_contracts/vault/auto_compounder.algo.ts:44
    // this.stakingPoolContract.value = stakingPool
    frame_dig -4
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:25
    // rewardDistributor = GlobalState<bytes>()
    pushbytes "rewardDistributor"
    // smart_contracts/vault/auto_compounder.algo.ts:45
    // this.rewardDistributor.value = rewardDistributorAddr
    frame_dig -3
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:20
    // compoundFeeRate = GlobalState<uint64>() // Fee in basis points
    bytec_3 // "compoundFeeRate"
    // smart_contracts/vault/auto_compounder.algo.ts:46
    // this.compoundFeeRate.value = compoundFee
    frame_dig -2
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:21
    // feeCollector = GlobalState<bytes>()
    bytec 15 // "feeCollector"
    // smart_contracts/vault/auto_compounder.algo.ts:47
    // this.feeCollector.value = feeCollector
    frame_dig -1
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:28
    // admin = GlobalState<bytes>()
    bytec 4 // "admin"
    // smart_contracts/vault/auto_compounder.algo.ts:48
    // this.admin.value = Txn.sender.bytes
    txn Sender
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:14
    // totalUsersEnabled = GlobalState<uint64>()
    bytec_2 // "totalUsersEnabled"
    // smart_contracts/vault/auto_compounder.algo.ts:50
    // this.totalUsersEnabled.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:15
    // totalCompounds = GlobalState<uint64>()
    bytec 5 // "totalCompounds"
    // smart_contracts/vault/auto_compounder.algo.ts:51
    // this.totalCompounds.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:16
    // totalRewardsCompounded = GlobalState<uint64>()
    bytec 7 // "totalRewardsCompounded"
    // smart_contracts/vault/auto_compounder.algo.ts:52
    // this.totalRewardsCompounded.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:17
    // lastGlobalCompound = GlobalState<uint64>()
    bytec 16 // "lastGlobalCompound"
    // smart_contracts/vault/auto_compounder.algo.ts:53
    // this.lastGlobalCompound.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:29
    // compoundsActive = GlobalState<boolean>()
    bytec_1 // "compoundsActive"
    // smart_contracts/vault/auto_compounder.algo.ts:54
    // this.compoundsActive.value = true
    intc_1 // 1
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:32
    // averageEfficiency = GlobalState<uint64>()
    bytec 8 // "averageEfficiency"
    // smart_contracts/vault/auto_compounder.algo.ts:55
    // this.averageEfficiency.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:33
    // bestEfficiency = GlobalState<uint64>()
    bytec 9 // "bestEfficiency"
    // smart_contracts/vault/auto_compounder.algo.ts:56
    // this.bestEfficiency.value = 0
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.enableAutoCompound(frequency: uint64, threshold: uint64, maxGasFee: uint64, slippageTolerance: uint64) -> void:
enableAutoCompound:
    // smart_contracts/vault/auto_compounder.algo.ts:59-65
    // @abimethod()
    // enableAutoCompound(
    //   frequency: uint64,
    //   threshold: uint64,
    //   maxGasFee: uint64,
    //   slippageTolerance: uint64
    // ): void {
    proto 4 0
    // smart_contracts/vault/auto_compounder.algo.ts:29
    // compoundsActive = GlobalState<boolean>()
    intc_0 // 0
    bytec_1 // "compoundsActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:66
    // assert(this.compoundsActive.value)
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:67
    // assert(frequency >= 3600) // Minimum 1 hour between compounds
    frame_dig -4
    pushint 3600 // 3600
    >=
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:68
    // assert(threshold > 0)
    frame_dig -3
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:69
    // assert(slippageTolerance <= 1000) // Max 10% slippage
    frame_dig -1
    pushint 1000 // 1000
    <=
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:70
    // const user = Txn.sender.bytes
    txn Sender
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:71
    // const enabledKey = concat(user, Bytes('_enabled'))
    bytec 6 // "_enabled"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dup
    uncover 2
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:72
    // const frequencyKey = concat(user, Bytes('_frequency'))
    bytec 10 // "_frequency"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    cover 2
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:73
    // const thresholdKey = concat(user, Bytes('_threshold'))
    bytec 11 // "_threshold"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    cover 2
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:74
    // const maxGasFeeKey = concat(user, Bytes('_maxGasFee'))
    bytec 12 // "_maxGasFee"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    cover 2
    // smart_contracts/vault/auto_compounder.algo.ts:75
    // const slippageToleranceKey = concat(user, Bytes('_slippageTolerance'))
    bytec 17 // "_slippageTolerance"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    // smart_contracts/vault/auto_compounder.algo.ts:76
    // const wasEnabled = Box<uint64>({ key: enabledKey }).exists ? Box<uint64>({ key: enabledKey }).value === 1 : false
    box_len
    bury 1
    bz enableAutoCompound_ternary_false@2
    frame_dig 0
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    intc_1 // 1
    ==

enableAutoCompound_ternary_merge@3:
    // smart_contracts/vault/auto_compounder.algo.ts:77
    // Box<uint64>({ key: enabledKey }).value = 1
    intc_1 // 1
    itob
    frame_dig 0
    swap
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:78
    // Box<uint64>({ key: frequencyKey }).value = frequency
    frame_dig -4
    itob
    frame_dig 1
    swap
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:79
    // Box<uint64>({ key: thresholdKey }).value = threshold
    frame_dig -3
    itob
    frame_dig 2
    swap
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:80
    // Box<uint64>({ key: maxGasFeeKey }).value = maxGasFee
    frame_dig -2
    itob
    frame_dig 3
    swap
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:81
    // Box<uint64>({ key: slippageToleranceKey }).value = slippageTolerance
    frame_dig -1
    itob
    frame_dig 4
    swap
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:82
    // if (!wasEnabled) {
    bnz enableAutoCompound_after_if_else@5
    // smart_contracts/vault/auto_compounder.algo.ts:14
    // totalUsersEnabled = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalUsersEnabled"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:83
    // this.totalUsersEnabled.value = this.totalUsersEnabled.value + 1
    intc_1 // 1
    +
    // smart_contracts/vault/auto_compounder.algo.ts:14
    // totalUsersEnabled = GlobalState<uint64>()
    bytec_2 // "totalUsersEnabled"
    // smart_contracts/vault/auto_compounder.algo.ts:83
    // this.totalUsersEnabled.value = this.totalUsersEnabled.value + 1
    swap
    app_global_put

enableAutoCompound_after_if_else@5:
    retsub

enableAutoCompound_ternary_false@2:
    // smart_contracts/vault/auto_compounder.algo.ts:76
    // const wasEnabled = Box<uint64>({ key: enabledKey }).exists ? Box<uint64>({ key: enabledKey }).value === 1 : false
    intc_0 // 0
    b enableAutoCompound_ternary_merge@3


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.disableAutoCompound() -> void:
disableAutoCompound:
    // smart_contracts/vault/auto_compounder.algo.ts:87-88
    // @abimethod()
    // disableAutoCompound(): void {
    proto 0 0
    // smart_contracts/vault/auto_compounder.algo.ts:89
    // const user = Txn.sender.bytes
    txn Sender
    // smart_contracts/vault/auto_compounder.algo.ts:90
    // const enabledKey = concat(user, Bytes('_enabled'))
    bytec 6 // "_enabled"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dupn 2
    // smart_contracts/vault/auto_compounder.algo.ts:91
    // assert(Box<uint64>({ key: enabledKey }).exists)
    box_len
    bury 1
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:92
    // const wasEnabled = Box<uint64>({ key: enabledKey }).value === 1
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    intc_1 // 1
    ==
    // smart_contracts/vault/auto_compounder.algo.ts:93
    // if (wasEnabled) {
    bz disableAutoCompound_after_if_else@2
    // smart_contracts/vault/auto_compounder.algo.ts:94
    // Box<uint64>({ key: enabledKey }).value = 0
    intc_0 // 0
    itob
    frame_dig 0
    swap
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:14
    // totalUsersEnabled = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalUsersEnabled"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:95
    // this.totalUsersEnabled.value = this.totalUsersEnabled.value - 1
    intc_1 // 1
    -
    // smart_contracts/vault/auto_compounder.algo.ts:14
    // totalUsersEnabled = GlobalState<uint64>()
    bytec_2 // "totalUsersEnabled"
    // smart_contracts/vault/auto_compounder.algo.ts:95
    // this.totalUsersEnabled.value = this.totalUsersEnabled.value - 1
    swap
    app_global_put

disableAutoCompound_after_if_else@2:
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.triggerCompound(user: bytes, pendingRewards: uint64) -> uint64:
triggerCompound:
    // smart_contracts/vault/auto_compounder.algo.ts:99-100
    // @abimethod()
    // triggerCompound(user: bytes, pendingRewards: uint64): uint64 {
    proto 2 1
    intc_0 // 0
    pushbytes ""
    dupn 2
    // smart_contracts/vault/auto_compounder.algo.ts:29
    // compoundsActive = GlobalState<boolean>()
    intc_0 // 0
    bytec_1 // "compoundsActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:101
    // assert(this.compoundsActive.value)
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    frame_dig -2
    // smart_contracts/vault/auto_compounder.algo.ts:102
    // const enabledKey = concat(user, Bytes('_enabled'))
    bytec 6 // "_enabled"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dup
    frame_dig -2
    // smart_contracts/vault/auto_compounder.algo.ts:103
    // const frequencyKey = concat(user, Bytes('_frequency'))
    bytec 10 // "_frequency"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    frame_dig -2
    // smart_contracts/vault/auto_compounder.algo.ts:104
    // const thresholdKey = concat(user, Bytes('_threshold'))
    bytec 11 // "_threshold"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    frame_dig -2
    // smart_contracts/vault/auto_compounder.algo.ts:105
    // const maxGasFeeKey = concat(user, Bytes('_maxGasFee'))
    bytec 12 // "_maxGasFee"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    // smart_contracts/vault/auto_compounder.algo.ts:106
    // assert(Box<uint64>({ key: enabledKey }).exists && Box<uint64>({ key: enabledKey }).value === 1)
    box_len
    bury 1
    bz triggerCompound_bool_false@3
    frame_dig 4
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    intc_1 // 1
    ==
    bz triggerCompound_bool_false@3
    intc_1 // 1

triggerCompound_bool_merge@4:
    // smart_contracts/vault/auto_compounder.algo.ts:106
    // assert(Box<uint64>({ key: enabledKey }).exists && Box<uint64>({ key: enabledKey }).value === 1)
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:107
    // const frequency = Box<uint64>({ key: frequencyKey }).value
    frame_dig 5
    box_get
    swap
    btoi
    frame_bury 1
    assert // Box must have value
    // smart_contracts/vault/auto_compounder.algo.ts:108
    // const threshold = Box<uint64>({ key: thresholdKey }).value
    frame_dig 6
    box_get
    swap
    btoi
    frame_bury 3
    assert // Box must have value
    // smart_contracts/vault/auto_compounder.algo.ts:109
    // const maxGasFee = Box<uint64>({ key: maxGasFeeKey }).value
    frame_dig 7
    box_get
    swap
    btoi
    frame_bury 2
    assert // Box must have value
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    frame_dig -2
    // smart_contracts/vault/auto_compounder.algo.ts:111
    // const lastCompoundKey = concat(user, Bytes('_lastCompound'))
    bytec 13 // "_lastCompound"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dup
    frame_bury 0
    // smart_contracts/vault/auto_compounder.algo.ts:112
    // const lastCompound = Box<uint64>({ key: lastCompoundKey }).exists ? Box<uint64>({ key: lastCompoundKey }).value : 0 as uint64
    box_len
    bury 1
    bz triggerCompound_ternary_false@6
    frame_dig 0
    box_get
    swap
    btoi
    swap
    assert // Box must have value

triggerCompound_ternary_merge@7:
    // smart_contracts/vault/auto_compounder.algo.ts:113
    // assert(Global.latestTimestamp >= lastCompound + frequency)
    global LatestTimestamp
    swap
    frame_dig 1
    +
    >=
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:114
    // assert(pendingRewards >= threshold)
    frame_dig -1
    frame_dig 3
    >=
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:366
    // return 3000 // For payment + potential contract call transactions
    intc_3 // 3000
    // smart_contracts/vault/auto_compounder.algo.ts:117
    // assert(gasCost <= maxGasFee)
    frame_dig 2
    <=
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:118
    // const efficiency = this.calculateCompoundEfficiency(pendingRewards, gasCost)
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:366
    // return 3000 // For payment + potential contract call transactions
    intc_3 // 3000
    // smart_contracts/vault/auto_compounder.algo.ts:118
    // const efficiency = this.calculateCompoundEfficiency(pendingRewards, gasCost)
    callsub calculateCompoundEfficiency
    // smart_contracts/vault/auto_compounder.algo.ts:120
    // const compoundedAmount = this.executeCompound(user, pendingRewards, gasCost)
    frame_dig -2
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:366
    // return 3000 // For payment + potential contract call transactions
    intc_3 // 3000
    // smart_contracts/vault/auto_compounder.algo.ts:120
    // const compoundedAmount = this.executeCompound(user, pendingRewards, gasCost)
    callsub executeCompound
    // smart_contracts/vault/auto_compounder.algo.ts:122
    // this.recordCompoundHistory(user, pendingRewards, compoundedAmount, gasCost, efficiency)
    frame_dig -2
    frame_dig -1
    dig 2
    // smart_contracts/vault/auto_compounder.algo.ts:366
    // return 3000 // For payment + potential contract call transactions
    intc_3 // 3000
    // smart_contracts/vault/auto_compounder.algo.ts:122
    // this.recordCompoundHistory(user, pendingRewards, compoundedAmount, gasCost, efficiency)
    dig 5
    callsub recordCompoundHistory
    // smart_contracts/vault/auto_compounder.algo.ts:124
    // this.updateGlobalStats(compoundedAmount, efficiency)
    dup
    uncover 2
    callsub updateGlobalStats
    // smart_contracts/vault/auto_compounder.algo.ts:126
    // Box<uint64>({ key: lastCompoundKey }).value = Global.latestTimestamp
    global LatestTimestamp
    itob
    frame_dig 0
    swap
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:127
    // return compoundedAmount as uint64
    frame_bury 0
    retsub

triggerCompound_ternary_false@6:
    // smart_contracts/vault/auto_compounder.algo.ts:112
    // const lastCompound = Box<uint64>({ key: lastCompoundKey }).exists ? Box<uint64>({ key: lastCompoundKey }).value : 0 as uint64
    intc_0 // 0
    b triggerCompound_ternary_merge@7

triggerCompound_bool_false@3:
    intc_0 // 0
    b triggerCompound_bool_merge@4


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.executeCompound(user: bytes, rewardAmount: uint64, gasCost: uint64) -> uint64:
executeCompound:
    // smart_contracts/vault/auto_compounder.algo.ts:130
    // executeCompound(user: bytes, rewardAmount: uint64, gasCost: uint64): uint64 {
    proto 3 1
    // smart_contracts/vault/auto_compounder.algo.ts:20
    // compoundFeeRate = GlobalState<uint64>() // Fee in basis points
    intc_0 // 0
    bytec_3 // "compoundFeeRate"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:132
    // const compoundFee = (rewardAmount * this.compoundFeeRate.value) / 10000 as uint64
    frame_dig -2
    *
    intc 4 // 10000
    /
    // smart_contracts/vault/auto_compounder.algo.ts:143
    // const netReward = rewardAmount - compoundFee - gasCost as uint64
    frame_dig -2
    swap
    -
    frame_dig -1
    -
    // smart_contracts/vault/auto_compounder.algo.ts:154
    // return netReward as uint64
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.batchCompound(users: bytes, pendingRewardsArray: bytes) -> uint64:
batchCompound:
    // smart_contracts/vault/auto_compounder.algo.ts:157-158
    // @abimethod()
    // batchCompound(users: bytes[], pendingRewardsArray: uint64[]): uint64 {
    proto 2 1
    intc_0 // 0
    // smart_contracts/vault/auto_compounder.algo.ts:29
    // compoundsActive = GlobalState<boolean>()
    dupn 10
    bytec_1 // "compoundsActive"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:159
    // assert(this.compoundsActive.value)
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:162
    // let totalCompounded: uint64 = 0
    intc_0 // 0
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:165
    // if (users.length > 0 && pendingRewardsArray.length > 0) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    uncover 2
    swap
    bz batchCompound_after_if_else@5
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@5
    // smart_contracts/vault/auto_compounder.algo.ts:166
    // if (this.isEligibleForCompound(users[0])) {
    frame_dig -2
    extract 2 0
    frame_dig 11
    assert // Index access is out of bounds
    dup
    intc_0 // 0
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 4
    callsub isEligibleForCompound
    bz batchCompound_after_if_else@4
    // smart_contracts/vault/auto_compounder.algo.ts:167
    // const compounded = this.triggerCompound(users[0], pendingRewardsArray[0])
    frame_dig -1
    intc_2 // 2
    extract_uint64
    frame_dig 4
    swap
    callsub triggerCompound
    frame_bury 10

batchCompound_after_if_else@4:
    frame_dig 10
    frame_bury 12

batchCompound_after_if_else@5:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:171
    // if (users.length > 1 && pendingRewardsArray.length > 1) {
    frame_dig 11
    intc_1 // 1
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@10
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@10
    // smart_contracts/vault/auto_compounder.algo.ts:172
    // if (this.isEligibleForCompound(users[1])) {
    frame_dig -2
    extract 2 0
    intc_1 // 1
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    intc_2 // 2
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 0
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@10
    // smart_contracts/vault/auto_compounder.algo.ts:173
    // const compounded = this.triggerCompound(users[1], pendingRewardsArray[1])
    frame_dig -1
    pushint 10 // 10
    extract_uint64
    frame_dig 0
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:174
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@10:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:177
    // if (users.length > 2 && pendingRewardsArray.length > 2) {
    frame_dig 11
    intc_2 // 2
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@15
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_2 // 2
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@15
    // smart_contracts/vault/auto_compounder.algo.ts:178
    // if (this.isEligibleForCompound(users[2])) {
    frame_dig -2
    extract 2 0
    intc_2 // 2
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 4 // 4
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 1
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@15
    // smart_contracts/vault/auto_compounder.algo.ts:179
    // const compounded = this.triggerCompound(users[2], pendingRewardsArray[2])
    frame_dig -1
    pushint 18 // 18
    extract_uint64
    frame_dig 1
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:180
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@15:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:183
    // if (users.length > 3 && pendingRewardsArray.length > 3) {
    frame_dig 11
    pushint 3 // 3
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@20
    frame_dig -1
    intc_0 // 0
    extract_uint16
    pushint 3 // 3
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@20
    // smart_contracts/vault/auto_compounder.algo.ts:184
    // if (this.isEligibleForCompound(users[3])) {
    frame_dig -2
    extract 2 0
    pushint 3 // 3
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 6 // 6
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 2
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@20
    // smart_contracts/vault/auto_compounder.algo.ts:185
    // const compounded = this.triggerCompound(users[3], pendingRewardsArray[3])
    frame_dig -1
    pushint 26 // 26
    extract_uint64
    frame_dig 2
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:186
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@20:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:189
    // if (users.length > 4 && pendingRewardsArray.length > 4) {
    frame_dig 11
    pushint 4 // 4
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@25
    frame_dig -1
    intc_0 // 0
    extract_uint16
    pushint 4 // 4
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@25
    // smart_contracts/vault/auto_compounder.algo.ts:190
    // if (this.isEligibleForCompound(users[4])) {
    frame_dig -2
    extract 2 0
    pushint 4 // 4
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 8 // 8
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 3
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@25
    // smart_contracts/vault/auto_compounder.algo.ts:191
    // const compounded = this.triggerCompound(users[4], pendingRewardsArray[4])
    frame_dig -1
    pushint 34 // 34
    extract_uint64
    frame_dig 3
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:192
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@25:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:195
    // if (users.length > 5 && pendingRewardsArray.length > 5) {
    frame_dig 11
    pushint 5 // 5
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@30
    frame_dig -1
    intc_0 // 0
    extract_uint16
    pushint 5 // 5
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@30
    // smart_contracts/vault/auto_compounder.algo.ts:196
    // if (this.isEligibleForCompound(users[5])) {
    frame_dig -2
    extract 2 0
    pushint 5 // 5
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 10 // 10
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 5
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@30
    // smart_contracts/vault/auto_compounder.algo.ts:197
    // const compounded = this.triggerCompound(users[5], pendingRewardsArray[5])
    frame_dig -1
    pushint 42 // 42
    extract_uint64
    frame_dig 5
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:198
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@30:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:201
    // if (users.length > 6 && pendingRewardsArray.length > 6) {
    frame_dig 11
    pushint 6 // 6
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@35
    frame_dig -1
    intc_0 // 0
    extract_uint16
    pushint 6 // 6
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@35
    // smart_contracts/vault/auto_compounder.algo.ts:202
    // if (this.isEligibleForCompound(users[6])) {
    frame_dig -2
    extract 2 0
    pushint 6 // 6
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 12 // 12
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 6
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@35
    // smart_contracts/vault/auto_compounder.algo.ts:203
    // const compounded = this.triggerCompound(users[6], pendingRewardsArray[6])
    frame_dig -1
    pushint 50 // 50
    extract_uint64
    frame_dig 6
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:204
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@35:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:207
    // if (users.length > 7 && pendingRewardsArray.length > 7) {
    frame_dig 11
    pushint 7 // 7
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@40
    frame_dig -1
    intc_0 // 0
    extract_uint16
    pushint 7 // 7
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@40
    // smart_contracts/vault/auto_compounder.algo.ts:208
    // if (this.isEligibleForCompound(users[7])) {
    frame_dig -2
    extract 2 0
    pushint 7 // 7
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 14 // 14
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 7
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@40
    // smart_contracts/vault/auto_compounder.algo.ts:209
    // const compounded = this.triggerCompound(users[7], pendingRewardsArray[7])
    frame_dig -1
    pushint 58 // 58
    extract_uint64
    frame_dig 7
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:210
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@40:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:213
    // if (users.length > 8 && pendingRewardsArray.length > 8) {
    frame_dig 11
    pushint 8 // 8
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@45
    frame_dig -1
    intc_0 // 0
    extract_uint16
    pushint 8 // 8
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@45
    // smart_contracts/vault/auto_compounder.algo.ts:214
    // if (this.isEligibleForCompound(users[8])) {
    frame_dig -2
    extract 2 0
    pushint 8 // 8
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 16 // 16
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 8
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@45
    // smart_contracts/vault/auto_compounder.algo.ts:215
    // const compounded = this.triggerCompound(users[8], pendingRewardsArray[8])
    frame_dig -1
    pushint 66 // 66
    extract_uint64
    frame_dig 8
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:216
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@45:
    frame_dig 12
    dup
    frame_bury 10
    // smart_contracts/vault/auto_compounder.algo.ts:219
    // if (users.length > 9 && pendingRewardsArray.length > 9) {
    frame_dig 11
    pushint 9 // 9
    >
    swap
    frame_bury 12
    bz batchCompound_after_if_else@50
    frame_dig -1
    intc_0 // 0
    extract_uint16
    pushint 9 // 9
    >
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@50
    // smart_contracts/vault/auto_compounder.algo.ts:220
    // if (this.isEligibleForCompound(users[9])) {
    frame_dig -2
    extract 2 0
    pushint 9 // 9
    frame_dig 11
    <
    assert // Index access is out of bounds
    dup
    pushint 18 // 18
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    dup
    frame_bury 9
    callsub isEligibleForCompound
    frame_dig 10
    frame_bury 12
    bz batchCompound_after_if_else@50
    // smart_contracts/vault/auto_compounder.algo.ts:221
    // const compounded = this.triggerCompound(users[9], pendingRewardsArray[9])
    frame_dig -1
    pushint 74 // 74
    extract_uint64
    frame_dig 9
    swap
    callsub triggerCompound
    // smart_contracts/vault/auto_compounder.algo.ts:222
    // totalCompounded = totalCompounded + compounded
    frame_dig 10
    +
    frame_bury 12

batchCompound_after_if_else@50:
    frame_dig 12
    // smart_contracts/vault/auto_compounder.algo.ts:225
    // return totalCompounded as uint64
    frame_bury 0
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.calculateCompoundEfficiency(rewardAmount: uint64, gasCost: uint64) -> uint64:
calculateCompoundEfficiency:
    // smart_contracts/vault/auto_compounder.algo.ts:228
    // calculateCompoundEfficiency(rewardAmount: uint64, gasCost: uint64): uint64 {
    proto 2 1
    pushbytes ""
    // smart_contracts/vault/auto_compounder.algo.ts:229
    // if (rewardAmount === 0 as uint64) return 0 as uint64
    frame_dig -2
    bnz calculateCompoundEfficiency_after_if_else@2
    intc_0 // 0
    swap
    retsub

calculateCompoundEfficiency_after_if_else@2:
    // smart_contracts/vault/auto_compounder.algo.ts:20
    // compoundFeeRate = GlobalState<uint64>() // Fee in basis points
    intc_0 // 0
    bytec_3 // "compoundFeeRate"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:230
    // const compoundFee = (rewardAmount * this.compoundFeeRate.value) / 10000 as uint64
    frame_dig -2
    *
    intc 4 // 10000
    /
    // smart_contracts/vault/auto_compounder.algo.ts:231
    // const totalCost = gasCost + compoundFee as uint64
    frame_dig -1
    +
    dup
    frame_bury 0
    // smart_contracts/vault/auto_compounder.algo.ts:232
    // const netReward = rewardAmount > totalCost ? rewardAmount - totalCost as uint64 : 0 as uint64
    frame_dig -2
    <
    bz calculateCompoundEfficiency_ternary_false@4
    frame_dig -2
    frame_dig 0
    -

calculateCompoundEfficiency_ternary_merge@5:
    // smart_contracts/vault/auto_compounder.algo.ts:233
    // return (netReward * 10000 as uint64) / rewardAmount as uint64
    intc 4 // 10000
    *
    frame_dig -2
    /
    swap
    retsub

calculateCompoundEfficiency_ternary_false@4:
    // smart_contracts/vault/auto_compounder.algo.ts:232
    // const netReward = rewardAmount > totalCost ? rewardAmount - totalCost as uint64 : 0 as uint64
    intc_0 // 0
    b calculateCompoundEfficiency_ternary_merge@5


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.recordCompoundHistory(user: bytes, rewardAmount: uint64, compoundedAmount: uint64, gasCost: uint64, efficiency: uint64) -> void:
recordCompoundHistory:
    // smart_contracts/vault/auto_compounder.algo.ts:236-242
    // recordCompoundHistory(
    //   user: bytes,
    //   rewardAmount: uint64,
    //   compoundedAmount: uint64,
    //   gasCost: uint64,
    //   efficiency: uint64
    // ): void {
    proto 5 0
    // smart_contracts/vault/auto_compounder.algo.ts:244
    // const ts = Global.latestTimestamp
    global LatestTimestamp
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    frame_dig -5
    // smart_contracts/vault/auto_compounder.algo.ts:245
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_reward')) }).value = rewardAmount
    pushbytes "_history_"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    // smart_contracts/vault/auto_compounder.algo.ts:9
    // return Bytes(x)
    swap
    itob
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    swap
    dig 1
    concat
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:245
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_reward')) }).value = rewardAmount
    pushbytes "_reward"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    // smart_contracts/vault/auto_compounder.algo.ts:245
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_reward')) }).value = rewardAmount
    frame_dig -4
    itob
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:246
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_compounded')) }).value = compoundedAmount
    pushbytes "_compounded"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    // smart_contracts/vault/auto_compounder.algo.ts:246
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_compounded')) }).value = compoundedAmount
    frame_dig -3
    itob
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:247
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_gas')) }).value = gasCost
    pushbytes "_gas"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    // smart_contracts/vault/auto_compounder.algo.ts:247
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_gas')) }).value = gasCost
    frame_dig -2
    itob
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    dup
    // smart_contracts/vault/auto_compounder.algo.ts:248
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_eff')) }).value = efficiency
    pushbytes "_eff"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    // smart_contracts/vault/auto_compounder.algo.ts:248
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_eff')) }).value = efficiency
    frame_dig -1
    itob
    box_put
    // smart_contracts/vault/auto_compounder.algo.ts:249
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_ts')) }).value = ts
    pushbytes "_ts"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    // smart_contracts/vault/auto_compounder.algo.ts:249
    // Box<uint64>({ key: concat(concat(concat(user, Bytes('_history_')), uint64ToBytes(ts)), Bytes('_ts')) }).value = ts
    swap
    box_put
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.updateGlobalStats(compoundedAmount: uint64, efficiency: uint64) -> void:
updateGlobalStats:
    // smart_contracts/vault/auto_compounder.algo.ts:252
    // updateGlobalStats(compoundedAmount: uint64, efficiency: uint64): void {
    proto 2 0
    // smart_contracts/vault/auto_compounder.algo.ts:15
    // totalCompounds = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalCompounds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:253
    // this.totalCompounds.value = this.totalCompounds.value + 1
    intc_1 // 1
    +
    // smart_contracts/vault/auto_compounder.algo.ts:15
    // totalCompounds = GlobalState<uint64>()
    bytec 5 // "totalCompounds"
    // smart_contracts/vault/auto_compounder.algo.ts:253
    // this.totalCompounds.value = this.totalCompounds.value + 1
    swap
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:16
    // totalRewardsCompounded = GlobalState<uint64>()
    intc_0 // 0
    bytec 7 // "totalRewardsCompounded"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:254
    // this.totalRewardsCompounded.value = this.totalRewardsCompounded.value + compoundedAmount
    frame_dig -2
    +
    // smart_contracts/vault/auto_compounder.algo.ts:16
    // totalRewardsCompounded = GlobalState<uint64>()
    bytec 7 // "totalRewardsCompounded"
    // smart_contracts/vault/auto_compounder.algo.ts:254
    // this.totalRewardsCompounded.value = this.totalRewardsCompounded.value + compoundedAmount
    swap
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:17
    // lastGlobalCompound = GlobalState<uint64>()
    bytec 16 // "lastGlobalCompound"
    // smart_contracts/vault/auto_compounder.algo.ts:255
    // this.lastGlobalCompound.value = Global.latestTimestamp
    global LatestTimestamp
    app_global_put
    // smart_contracts/vault/auto_compounder.algo.ts:33
    // bestEfficiency = GlobalState<uint64>()
    intc_0 // 0
    bytec 9 // "bestEfficiency"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:256
    // if (efficiency > this.bestEfficiency.value) {
    frame_dig -1
    <
    bz updateGlobalStats_after_if_else@2
    // smart_contracts/vault/auto_compounder.algo.ts:33
    // bestEfficiency = GlobalState<uint64>()
    bytec 9 // "bestEfficiency"
    // smart_contracts/vault/auto_compounder.algo.ts:257
    // this.bestEfficiency.value = efficiency
    frame_dig -1
    app_global_put

updateGlobalStats_after_if_else@2:
    // smart_contracts/vault/auto_compounder.algo.ts:32
    // averageEfficiency = GlobalState<uint64>()
    intc_0 // 0
    bytec 8 // "averageEfficiency"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:15
    // totalCompounds = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalCompounds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:262
    // this.averageEfficiency.value = ((currentAvg * (totalCount - 1)) + efficiency) / totalCount
    dup
    intc_1 // 1
    -
    uncover 2
    *
    frame_dig -1
    +
    swap
    /
    // smart_contracts/vault/auto_compounder.algo.ts:32
    // averageEfficiency = GlobalState<uint64>()
    bytec 8 // "averageEfficiency"
    // smart_contracts/vault/auto_compounder.algo.ts:262
    // this.averageEfficiency.value = ((currentAvg * (totalCount - 1)) + efficiency) / totalCount
    swap
    app_global_put
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.updateCompoundFee(newFeeRate: uint64) -> void:
updateCompoundFee:
    // smart_contracts/vault/auto_compounder.algo.ts:266-267
    // @abimethod()
    // updateCompoundFee(newFeeRate: uint64): void {
    proto 1 0
    // smart_contracts/vault/auto_compounder.algo.ts:268
    // assert(Txn.sender.bytes === this.admin.value)
    txn Sender
    // smart_contracts/vault/auto_compounder.algo.ts:28
    // admin = GlobalState<bytes>()
    intc_0 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:268
    // assert(Txn.sender.bytes === this.admin.value)
    ==
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:269
    // assert(newFeeRate <= 1000) // Max 10% fee
    frame_dig -1
    pushint 1000 // 1000
    <=
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:20
    // compoundFeeRate = GlobalState<uint64>() // Fee in basis points
    bytec_3 // "compoundFeeRate"
    // smart_contracts/vault/auto_compounder.algo.ts:271
    // this.compoundFeeRate.value = newFeeRate
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.updateFeeCollector(newCollector: bytes) -> void:
updateFeeCollector:
    // smart_contracts/vault/auto_compounder.algo.ts:274-275
    // @abimethod()
    // updateFeeCollector(newCollector: bytes): void {
    proto 1 0
    // smart_contracts/vault/auto_compounder.algo.ts:276
    // assert(Txn.sender.bytes === this.admin.value)
    txn Sender
    // smart_contracts/vault/auto_compounder.algo.ts:28
    // admin = GlobalState<bytes>()
    intc_0 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:276
    // assert(Txn.sender.bytes === this.admin.value)
    ==
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:21
    // feeCollector = GlobalState<bytes>()
    bytec 15 // "feeCollector"
    // smart_contracts/vault/auto_compounder.algo.ts:278
    // this.feeCollector.value = newCollector
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.pauseCompounds() -> void:
pauseCompounds:
    // smart_contracts/vault/auto_compounder.algo.ts:283
    // assert(Txn.sender.bytes === this.admin.value)
    txn Sender
    // smart_contracts/vault/auto_compounder.algo.ts:28
    // admin = GlobalState<bytes>()
    intc_0 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:283
    // assert(Txn.sender.bytes === this.admin.value)
    ==
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:29
    // compoundsActive = GlobalState<boolean>()
    bytec_1 // "compoundsActive"
    // smart_contracts/vault/auto_compounder.algo.ts:285
    // this.compoundsActive.value = false
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.resumeCompounds() -> void:
resumeCompounds:
    // smart_contracts/vault/auto_compounder.algo.ts:290
    // assert(Txn.sender.bytes === this.admin.value)
    txn Sender
    // smart_contracts/vault/auto_compounder.algo.ts:28
    // admin = GlobalState<bytes>()
    intc_0 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:290
    // assert(Txn.sender.bytes === this.admin.value)
    ==
    assert
    // smart_contracts/vault/auto_compounder.algo.ts:29
    // compoundsActive = GlobalState<boolean>()
    bytec_1 // "compoundsActive"
    // smart_contracts/vault/auto_compounder.algo.ts:292
    // this.compoundsActive.value = true
    intc_1 // 1
    app_global_put
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.isEligibleForCompound(user: bytes) -> uint64:
isEligibleForCompound:
    // smart_contracts/vault/auto_compounder.algo.ts:296
    // isEligibleForCompound(user: bytes): boolean {
    proto 1 1
    intc_0 // 0
    pushbytes ""
    dupn 2
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:297
    // const enabledKey = concat(user, Bytes('_enabled'))
    bytec 6 // "_enabled"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dup
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:298
    // const frequencyKey = concat(user, Bytes('_frequency'))
    bytec 10 // "_frequency"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:299
    // const thresholdKey = concat(user, Bytes('_threshold'))
    bytec 11 // "_threshold"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:300
    // const maxGasFeeKey = concat(user, Bytes('_maxGasFee'))
    bytec 12 // "_maxGasFee"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    // smart_contracts/vault/auto_compounder.algo.ts:301
    // if (!Box<uint64>({ key: enabledKey }).exists || Box<uint64>({ key: enabledKey }).value !== 1) {
    box_len
    bury 1
    bz isEligibleForCompound_if_body@2
    frame_dig 4
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    intc_1 // 1
    !=
    bz isEligibleForCompound_after_if_else@3

isEligibleForCompound_if_body@2:
    // smart_contracts/vault/auto_compounder.algo.ts:302
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

isEligibleForCompound_after_if_else@3:
    // smart_contracts/vault/auto_compounder.algo.ts:304
    // const frequency = Box<uint64>({ key: frequencyKey }).value
    frame_dig 5
    box_get
    swap
    btoi
    frame_bury 1
    assert // Box must have value
    // smart_contracts/vault/auto_compounder.algo.ts:305
    // const threshold = Box<uint64>({ key: thresholdKey }).value
    frame_dig 6
    box_get
    swap
    btoi
    frame_bury 3
    assert // Box must have value
    // smart_contracts/vault/auto_compounder.algo.ts:306
    // const maxGasFee = Box<uint64>({ key: maxGasFeeKey }).value
    frame_dig 7
    box_get
    swap
    btoi
    frame_bury 2
    assert // Box must have value
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:307
    // const lastCompoundKey = concat(user, Bytes('_lastCompound'))
    bytec 13 // "_lastCompound"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dup
    frame_bury 0
    // smart_contracts/vault/auto_compounder.algo.ts:308
    // const lastCompound = Box<uint64>({ key: lastCompoundKey }).exists ? Box<uint64>({ key: lastCompoundKey }).value : 0 as uint64
    box_len
    bury 1
    bz isEligibleForCompound_ternary_false@5
    frame_dig 0
    box_get
    swap
    btoi
    swap
    assert // Box must have value

isEligibleForCompound_ternary_merge@6:
    // smart_contracts/vault/auto_compounder.algo.ts:309
    // if (Global.latestTimestamp < lastCompound + frequency) {
    global LatestTimestamp
    swap
    frame_dig 1
    +
    <
    bz isEligibleForCompound_after_if_else@8
    // smart_contracts/vault/auto_compounder.algo.ts:310
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

isEligibleForCompound_after_if_else@8:
    // smart_contracts/vault/auto_compounder.algo.ts:313
    // if (pendingRewards < threshold) {
    frame_dig 3
    bz isEligibleForCompound_after_if_else@10
    // smart_contracts/vault/auto_compounder.algo.ts:314
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

isEligibleForCompound_after_if_else@10:
    // smart_contracts/vault/auto_compounder.algo.ts:366
    // return 3000 // For payment + potential contract call transactions
    intc_3 // 3000
    // smart_contracts/vault/auto_compounder.algo.ts:317
    // if (gasCost > maxGasFee) {
    frame_dig 2
    >
    bz isEligibleForCompound_after_if_else@12
    // smart_contracts/vault/auto_compounder.algo.ts:318
    // return false
    intc_0 // 0
    frame_bury 0
    retsub

isEligibleForCompound_after_if_else@12:
    // smart_contracts/vault/auto_compounder.algo.ts:320
    // return true
    intc_1 // 1
    frame_bury 0
    retsub

isEligibleForCompound_ternary_false@5:
    // smart_contracts/vault/auto_compounder.algo.ts:308
    // const lastCompound = Box<uint64>({ key: lastCompoundKey }).exists ? Box<uint64>({ key: lastCompoundKey }).value : 0 as uint64
    intc_0 // 0
    b isEligibleForCompound_ternary_merge@6


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.getUserSettings(user: bytes) -> uint64, uint64, uint64, uint64, uint64:
getUserSettings:
    // smart_contracts/vault/auto_compounder.algo.ts:323
    // getUserSettings(user: bytes): [uint64, uint64, uint64, uint64, uint64] {
    proto 1 5
    pushbytes ""
    dupn 3
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:325
    // const enabledKey = concat(user, Bytes('_enabled'))
    bytec 6 // "_enabled"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dup
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:326
    // const frequencyKey = concat(user, Bytes('_frequency'))
    bytec 10 // "_frequency"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:327
    // const thresholdKey = concat(user, Bytes('_threshold'))
    bytec 11 // "_threshold"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:328
    // const maxGasFeeKey = concat(user, Bytes('_maxGasFee'))
    bytec 12 // "_maxGasFee"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:329
    // const slippageToleranceKey = concat(user, Bytes('_slippageTolerance'))
    bytec 17 // "_slippageTolerance"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    swap
    // smart_contracts/vault/auto_compounder.algo.ts:330
    // const enabled = Box<uint64>({ key: enabledKey }).exists ? Box<uint64>({ key: enabledKey }).value : 0 as uint64
    box_len
    bury 1
    bz getUserSettings_ternary_false@2
    frame_dig 4
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    frame_bury 0

getUserSettings_ternary_merge@3:
    // smart_contracts/vault/auto_compounder.algo.ts:331
    // const frequency = Box<uint64>({ key: frequencyKey }).exists ? Box<uint64>({ key: frequencyKey }).value : 0 as uint64
    frame_dig 5
    box_len
    bury 1
    bz getUserSettings_ternary_false@5
    frame_dig 5
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    frame_bury 1

getUserSettings_ternary_merge@6:
    // smart_contracts/vault/auto_compounder.algo.ts:332
    // const threshold = Box<uint64>({ key: thresholdKey }).exists ? Box<uint64>({ key: thresholdKey }).value : 0 as uint64
    frame_dig 6
    box_len
    bury 1
    bz getUserSettings_ternary_false@8
    frame_dig 6
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    frame_bury 3

getUserSettings_ternary_merge@9:
    // smart_contracts/vault/auto_compounder.algo.ts:333
    // const maxGasFee = Box<uint64>({ key: maxGasFeeKey }).exists ? Box<uint64>({ key: maxGasFeeKey }).value : 0 as uint64
    frame_dig 7
    box_len
    bury 1
    bz getUserSettings_ternary_false@11
    frame_dig 7
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    frame_bury 2

getUserSettings_ternary_merge@12:
    // smart_contracts/vault/auto_compounder.algo.ts:334
    // const slippageTolerance = Box<uint64>({ key: slippageToleranceKey }).exists ? Box<uint64>({ key: slippageToleranceKey }).value : 0 as uint64
    frame_dig 8
    box_len
    bury 1
    bz getUserSettings_ternary_false@14
    frame_dig 8
    box_get
    swap
    btoi
    swap
    assert // Box must have value

getUserSettings_ternary_merge@15:
    // smart_contracts/vault/auto_compounder.algo.ts:335
    // return [enabled, frequency, threshold, maxGasFee, slippageTolerance]
    frame_dig 0
    frame_dig 1
    frame_dig 3
    frame_dig 2
    uncover 4
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

getUserSettings_ternary_false@14:
    // smart_contracts/vault/auto_compounder.algo.ts:334
    // const slippageTolerance = Box<uint64>({ key: slippageToleranceKey }).exists ? Box<uint64>({ key: slippageToleranceKey }).value : 0 as uint64
    intc_0 // 0
    b getUserSettings_ternary_merge@15

getUserSettings_ternary_false@11:
    // smart_contracts/vault/auto_compounder.algo.ts:333
    // const maxGasFee = Box<uint64>({ key: maxGasFeeKey }).exists ? Box<uint64>({ key: maxGasFeeKey }).value : 0 as uint64
    intc_0 // 0
    frame_bury 2
    b getUserSettings_ternary_merge@12

getUserSettings_ternary_false@8:
    // smart_contracts/vault/auto_compounder.algo.ts:332
    // const threshold = Box<uint64>({ key: thresholdKey }).exists ? Box<uint64>({ key: thresholdKey }).value : 0 as uint64
    intc_0 // 0
    frame_bury 3
    b getUserSettings_ternary_merge@9

getUserSettings_ternary_false@5:
    // smart_contracts/vault/auto_compounder.algo.ts:331
    // const frequency = Box<uint64>({ key: frequencyKey }).exists ? Box<uint64>({ key: frequencyKey }).value : 0 as uint64
    intc_0 // 0
    frame_bury 1
    b getUserSettings_ternary_merge@6

getUserSettings_ternary_false@2:
    // smart_contracts/vault/auto_compounder.algo.ts:330
    // const enabled = Box<uint64>({ key: enabledKey }).exists ? Box<uint64>({ key: enabledKey }).value : 0 as uint64
    intc_0 // 0
    frame_bury 0
    b getUserSettings_ternary_merge@3


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.getCompoundStats() -> uint64, uint64, uint64, uint64, uint64, uint64:
getCompoundStats:
    // smart_contracts/vault/auto_compounder.algo.ts:14
    // totalUsersEnabled = GlobalState<uint64>()
    intc_0 // 0
    bytec_2 // "totalUsersEnabled"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:15
    // totalCompounds = GlobalState<uint64>()
    intc_0 // 0
    bytec 5 // "totalCompounds"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:16
    // totalRewardsCompounded = GlobalState<uint64>()
    intc_0 // 0
    bytec 7 // "totalRewardsCompounded"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:32
    // averageEfficiency = GlobalState<uint64>()
    intc_0 // 0
    bytec 8 // "averageEfficiency"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:33
    // bestEfficiency = GlobalState<uint64>()
    intc_0 // 0
    bytec 9 // "bestEfficiency"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:20
    // compoundFeeRate = GlobalState<uint64>() // Fee in basis points
    intc_0 // 0
    bytec_3 // "compoundFeeRate"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/vault/auto_compounder.algo.ts:340-347
    // return [
    //   this.totalUsersEnabled.value,
    //   this.totalCompounds.value,
    //   this.totalRewardsCompounded.value,
    //   this.averageEfficiency.value,
    //   this.bestEfficiency.value,
    //   this.compoundFeeRate.value
    // ]
    retsub


// smart_contracts/vault/auto_compounder.algo.ts::AutoCompounder.calculateOptimalCompoundTime(user: bytes) -> uint64:
calculateOptimalCompoundTime:
    // smart_contracts/vault/auto_compounder.algo.ts:369
    // calculateOptimalCompoundTime(user: bytes): uint64 {
    proto 1 1
    intc_0 // 0
    // smart_contracts/vault/auto_compounder.algo.ts:370
    // const settings = this.getUserSettings(user)
    frame_dig -1
    callsub getUserSettings
    popn 3
    swap
    // smart_contracts/vault/auto_compounder.algo.ts:371
    // if (settings[0] !== 1 as uint64) {
    intc_1 // 1
    !=
    bz calculateOptimalCompoundTime_after_if_else@2
    // smart_contracts/vault/auto_compounder.algo.ts:372
    // return 0 as uint64
    intc_0 // 0
    frame_bury 0
    retsub

calculateOptimalCompoundTime_after_if_else@2:
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    frame_dig -1
    // smart_contracts/vault/auto_compounder.algo.ts:374
    // const lastCompoundKey = concat(user, Bytes('_lastCompound'))
    bytec 13 // "_lastCompound"
    // smart_contracts/vault/auto_compounder.algo.ts:5
    // return a.concat(b)
    concat
    dup
    frame_bury 0
    // smart_contracts/vault/auto_compounder.algo.ts:375
    // const lastCompound = Box<uint64>({ key: lastCompoundKey }).exists ? Box<uint64>({ key: lastCompoundKey }).value : 0 as uint64
    box_len
    bury 1
    bz calculateOptimalCompoundTime_ternary_false@4
    frame_dig 0
    box_get
    swap
    btoi
    swap
    assert // Box must have value

calculateOptimalCompoundTime_ternary_merge@5:
    // smart_contracts/vault/auto_compounder.algo.ts:376
    // return lastCompound + settings[1] as uint64
    frame_dig 1
    +
    frame_bury 0
    retsub

calculateOptimalCompoundTime_ternary_false@4:
    // smart_contracts/vault/auto_compounder.algo.ts:375
    // const lastCompound = Box<uint64>({ key: lastCompoundKey }).exists ? Box<uint64>({ key: lastCompoundKey }).value : 0 as uint64
    intc_0 // 0
    b calculateOptimalCompoundTime_ternary_merge@5
